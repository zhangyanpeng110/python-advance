概念：
    1.并发
        指在一个时间段内，有几个程序在同一个CPU上运行
        但是实际上任意时刻只有一个程序在CPU上运行
        比如：
            某个服务在某一时间段内可以处理的请求数量
    2.并行
        指任意时刻点上，有多个程序运行在多个CPU上
        比如：
            某台机器通过多核优势，实现同时处理接收到的请求
    3.同步
        代码调用IO操作，必须等待IO操作完成才返回的调用方式
    4.异步
        代码调用IO操作，不必等待IO操作完成就返回的调用方式
    5.阻塞
        指调用函数的时候，当前线程被挂起
        ***** 阻塞不会耗费CPU资源，但是会浪费CPU资源，因为当前CPU在空等
    6.非阻塞
        指调用函数的时候，当前线程不会被挂起，而是直接返回
        ***** 耗费CPU资源，因为期间会一直轮训调用内核函数询问数据是否已经准备好

      注意：
        ***** 同步、异步、阻塞、非阻塞 只会存在 IO操作是
        ***** 同步、异步     <<<===>>> 消息通信之间的机制
        ***** 阻塞、非阻塞    <<<===>>> 函数调用之间的机制

    7.C10K问题：
        1999年被提出的技术挑战，如何在一颗1GHz 2G内存 1Gbps 网络环境下，实现单台服务器为 10000个客户端提供FTP请求
        并发问题

    8.Unix中的五种I/O模型:
      参考：https://blog.csdn.net/ZWE7616175/article/details/80591587
        1)阻塞式I/O
        2)非阻塞式I/O
        3)I/O复用                           *****应用比较多，技术比较成熟
            select 模型，解决非阻塞I/O一直轮训调用内核函数的问题
            一个 select 可以监听多个应用程序

            还是存在：当数据准备好的时候，无法避免耗费将数据从内核拷贝到用户空间需要的时间
            三个模型:
                select
                poll
                epoll
                    根据生产环境判定，epoll性能不一定优于select
                    1)在并发高的情况下，连接活跃不是很高时epoll优于select
                    2)在并发不高情况下，连接活跃很高时select优于epoll
        4)信号驱动式I/O
        5)异步I/O（POSIX的aio_系列函数）       *****性能提升不是很明显，技术不够成熟
            当数据准备好的时候再发送，避免了耗费将数据从内核拷贝到用户空间需要的时间

    9.C10M问题
        如何利用8核 64GB 10Gbps 网络上如何保持1000万并发连接

    生成器是存在状态的，可以通过 close等方法操作，这些基础就奠定了可以通过生成器实现协程

    ***** 进程、线程 是操作系统进行调度的，属于内核级别
    ***** 协程是开发者进行调度的，属于函数级别，由开发者设计、调度如何进行

    总结：
        1)协程的调度依然是 事件循环+协程模式
        2)协程是单线程模式，它是在同一个线程中通过调度不同的函数进行执行实现的，不可在协程中加入类似于sleep()等耗时的代码
        3)协程的出现实际上就解决了 I/O多路复用模型(select/poll/epoll) + 回调 + 时间循环 实现并发时存在的问题(即代码可读性差、
          异常处理困难、共享状态管理困难),虽然前者解决了后者存在的问题，使得代码更健壮和可控性更高等，但后者的性能实际比前者稍微高些



